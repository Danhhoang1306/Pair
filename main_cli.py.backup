"""
Main Application - XAU/XAG Pair Trading System
Multi-threaded real-time trading system
"""

import sys
from pathlib import Path

# Ensure project root is in path (works even when imported from subdirectories)
project_root = Path(__file__).parent.resolve()
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

import threading
import queue
import time
import signal
from datetime import datetime
from typing import Dict, Any, Optional
import logging

from core.data_manager import DataManager
from core.mt5_trade_executor import MT5TradeExecutor
from core.realtime_market_data import RealTimeMarketData
from core.position_monitor import PositionMonitor
from core.setup_flag_manager import SetupFlagManager
from utils.data_preprocessor import DataPreprocessor
from utils.zscore_monitor import ZScoreMonitor
from models import HedgeRatioCalculator
from risk import PositionSizer, DrawdownMonitor, RiskChecker
from strategy import (SignalGenerator, OrderManager, PositionTracker, 
                      SignalType, OrderStatus)
from strategy.hybrid_rebalancer import HybridRebalancer
from utils.logger import setup_logging

logger = logging.getLogger(__name__)


class TradingSystem:
    """Multi-threaded pair trading system"""
    
    def __init__(self, 
                 account_balance: float = 100000,
                 config: Optional[Dict[str, Any]] = None):
        """
        Initialize trading system
        
        Args:
            account_balance: Account balance (from MT5)
            config: Complete trading configuration (dict or PairConfig)
                   If provided, ALL settings come from config!
                   If None, uses defaults
        
        Config can contain:
            - update_interval
            - max_positions
            - volume_multiplier
            - entry_threshold
            - exit_threshold
            - stop_loss_zscore
            - rolling_window_size
            - hedge_drift_threshold
            - max_position_pct
            - max_risk_pct
            - daily_loss_limit
            - enable_pyramiding
            - enable_hedge_adjustment
            - primary_symbol
            - secondary_symbol
            - ... and more!
        """
        self.account_balance = account_balance
        
        # Convert config to dict if it's a dataclass
        if config is not None and hasattr(config, 'to_dict'):
            config = config.to_dict()
        
        # Store config
        self.config = config or {}
        
        # Extract settings from config (with defaults)
        self.update_interval = self.config.get('update_interval', 60)
        self.max_positions = self.config.get('max_positions', 5)
        self.volume_multiplier = self.config.get('volume_multiplier', 1.0)
        
        # Threading
        self.running = False
        self.threads = []
        self.lock = threading.RLock()
        
        # Queues
        self.data_queue = queue.Queue(maxsize=10)
        self.signal_queue = queue.Queue(maxsize=10)
        
        # Components
        logger.info("Initializing components...")
        logger.info(f"Using config: update_interval={self.update_interval}, "
                   f"max_positions={self.max_positions}, "
                   f"volume_multiplier={self.volume_multiplier}")
        
        self.data_manager = DataManager()
        
        # MT5 TradeExecutor - use magic number and symbols from config!
        magic_number = self.config.get('magic_number', 234000)
        primary_symbol = self.config.get('primary_symbol', 'XAUUSD')
        secondary_symbol = self.config.get('secondary_symbol', 'XAGUSD')
        
        self.trade_executor = MT5TradeExecutor(
            magic_number=magic_number,
            volume_multiplier=self.volume_multiplier,
            primary_symbol=primary_symbol,
            secondary_symbol=secondary_symbol
        )
        self.preprocessor = DataPreprocessor()
        self.hedge_calculator = HedgeRatioCalculator()
        
        # Real-time market data manager
        self.market_data = RealTimeMarketData(
            data_manager=self.data_manager,
            preprocessor=self.preprocessor,
            hedge_calculator=self.hedge_calculator,
            historical_update_interval=3600  # Update historical every hour
        )
        
        # Apply rolling window from config
        rolling_window = self.config.get('rolling_window', 1000)
        self.market_data.rolling_window_size = rolling_window
        logger.info(f"Rolling window: {rolling_window} bars (responsive mode)")
        
        # Position sizer - now accepts config directly!
        self.position_sizer = PositionSizer(
            account_balance=account_balance,
            config=self.config  # â† Pass config!
        )
        
        # Drawdown monitor - now accepts config directly!
        self.drawdown_monitor = DrawdownMonitor(
            account_balance=account_balance,
            config=self.config  # â† Pass config!
        )
        
        # Store max drawdown limit for easy access
        self.max_drawdown_limit = self.config.get('max_risk_pct', 20.0) / 100.0  # Convert % to fraction
        
        # Risk checker - now accepts config directly!
        self.risk_checker = RiskChecker(config=self.config)
        
        # Signal generator - now accepts config directly!
        self.signal_generator = SignalGenerator(config=self.config)
        
        self.order_manager = OrderManager()
        self.position_tracker = PositionTracker()
        
        # Rebalancer with config
        stop_loss_zscore = self.config.get('stop_loss_zscore', 3.5)
        hedge_drift_threshold = self.config.get('hedge_drift_threshold', 0.05)
        enable_hedge_adjustment = self.config.get('enable_hedge_adjustment', True)
        enable_pyramiding = self.config.get('enable_pyramiding', True)
        
        self.rebalancer = HybridRebalancer(
            scale_interval=self.config.get('scale_interval', 0.5),
            max_zscore=stop_loss_zscore,
            initial_fraction=self.config.get('initial_fraction', 0.33),
            hedge_drift_threshold=hedge_drift_threshold,
            min_absolute_drift=self.config.get('min_absolute_drift', 0.01),
            min_adjustment_interval=self.config.get('min_adjustment_interval', 3600),
            enable_hedge_adjustment=enable_hedge_adjustment
        )
        logger.info(f"Rebalancer: pyramiding={enable_pyramiding}, "
                   f"hedge_adjustment={enable_hedge_adjustment}, "
                   f"drift_threshold={hedge_drift_threshold}, "
                   f"min_absolute_drift={self.config.get('min_absolute_drift', 0.01)}, "
                   f"scale_interval={self.config.get('scale_interval', 0.5)}, "
                   f"initial_fraction={self.config.get('initial_fraction', 0.33)}")
        
        # ZScore monitor from config
        zscore_history = self.config.get('zscore_history_size', 200)
        self.zscore_monitor = ZScoreMonitor(max_history=zscore_history)
        
        # Position Persistence from config
        from core.position_persistence import PositionPersistence
        position_dir = self.config.get('position_data_dir', 'positions')
        self.persistence = PositionPersistence(data_dir=position_dir)
        
        # Setup Flag Manager - tracks if setup is active
        self.flag_manager = SetupFlagManager(data_dir=position_dir)
        
        # Position Monitor - monitors MT5 positions in real-time
        self.position_monitor = PositionMonitor(
            check_interval=5,  # Check every 5 seconds
            user_response_timeout=60  # Wait 60 seconds for user response
        )
        
        # Set position monitor callbacks
        self.position_monitor.on_position_missing = self._handle_missing_positions
        self.position_monitor.on_user_confirmed = self._handle_user_rebalance
        self.position_monitor.on_user_timeout = self._handle_user_timeout
        
        # State
        self.current_snapshot = None
        self.current_signal = None
        self.last_update_time = None
        
        # Attribution state (for GUI display)
        self.current_attribution = None
        
        # MT5 ticket mapping
        self.mt5_tickets = {}
        
        logger.info(f"System initialized (balance=${account_balance:,.0f})")
    
    def _recover_positions(self):
        """
        Recover positions from disk after system restart
        
        Flow (according to flowchart):
        1. Check setup flag - if False, skip recovery
        2. Load positions from disk
        3. Check if they still exist on MT5 (by ticket)
        4. If incomplete â†’ Ask user (with timeout)
        5. If complete â†’ Ask user to continue
        """
        logger.info("="*80)
        logger.info("POSITION RECOVERY - Checking for saved positions...")
        logger.info("="*80)
        
        # STEP 1: Check setup flag
        if not self.flag_manager.is_setup_active():
            logger.info("âœ… No active setup flag - starting fresh")
            self.flag_manager.clear_flag()
            return
        
        logger.warning("âš ï¸  Active setup flag detected - checking MT5 positions...")
        setup_info = self.flag_manager.get_setup_info()
        if setup_info:
            logger.info(f"Setup ID: {setup_info.get('spread_id', 'UNKNOWN')[:8]}")
            logger.info(f"Activated: {setup_info.get('activated_at', 'UNKNOWN')}")
        
        # STEP 2: Cleanup orphaned positions first
        self.persistence.cleanup_orphaned_positions()
        
        # STEP 3: Load active positions
        persisted_positions = self.persistence.load_active_positions()
        
        if not persisted_positions:
            logger.warning("âš ï¸  Setup flag active but no positions found - clearing flag")
            self.flag_manager.mark_setup_inactive("No positions found")
            return
        
        logger.info(f"Found {len(persisted_positions)} saved positions")
        
        # STEP 4: Check if positions exist on MT5
        import MetaTrader5 as mt5
        mt5_positions = mt5.positions_get()
        if mt5_positions is None:
            logger.error("âŒ Failed to get MT5 positions - cannot recover")
            return
        
        mt5_tickets = {pos.ticket for pos in mt5_positions}
        saved_tickets = {pos.mt5_ticket for pos in persisted_positions.values()}
        
        missing_tickets = saved_tickets - mt5_tickets
        
        # SPECIAL CASE: ALL positions closed offline
        if len(mt5_tickets) == 0 and len(saved_tickets) > 0:
            logger.warning("="*80)
            logger.warning("âš ï¸  ALL POSITIONS CLOSED OFFLINE!")
            logger.warning("="*80)
            logger.warning("Detected scenario:")
            logger.warning(f"  â€¢ Saved positions: {len(saved_tickets)}")
            logger.warning(f"  â€¢ MT5 positions: 0")
            logger.warning(f"  â€¢ Conclusion: All positions manually closed while system offline")
            
            # Clean up everything
            logger.info("Cleaning up persisted data...")
            for spread_id in set(pos.spread_id for pos in persisted_positions.values()):
                self.persistence.archive_spread(spread_id, reason="all_closed_offline")
            
            self.flag_manager.mark_setup_inactive("All positions closed offline")
            logger.info("âœ… Cleanup complete - ready for fresh start")
            return
        
        if missing_tickets:
            # INCOMPLETE - positions were closed
            logger.error("="*80)
            logger.error("âš ï¸  INCOMPLETE SETUP - Some positions closed!")
            logger.error("="*80)
            for ticket in missing_tickets:
                logger.error(f"âŒ Missing ticket: {ticket}")
            
            # Ask user what to do
            self._startup_user_confirmation(
                complete=False,
                missing_tickets=missing_tickets,
                persisted_positions=persisted_positions
            )
            return
        
        # STEP 5: All positions exist - ask user to continue
        logger.info("="*80)
        logger.info("âœ… All saved positions found on MT5")
        logger.info("="*80)
        
        # Group by spread_id
        spreads = {}
        for pos_id, pers_pos in persisted_positions.items():
            spread_id = pers_pos.spread_id
            if spread_id not in spreads:
                spreads[spread_id] = []
            spreads[spread_id].append(pers_pos)
        
        for spread_id, positions in spreads.items():
            logger.info(f"Spread {spread_id[:8]}:")
            for pos in positions:
                logger.info(f"  â€¢ {pos.symbol} {pos.side} {pos.volume} lots "
                           f"@ {pos.entry_price:.2f} (Ticket: {pos.mt5_ticket})")
        
        # Ask user what to do
        self._startup_user_confirmation(
            complete=True,
            missing_tickets=set(),
            persisted_positions=persisted_positions
        )
    
    def _startup_user_confirmation(self, complete: bool, missing_tickets: set, 
                                   persisted_positions: dict):
        """
        Ask user for confirmation at startup
        
        Args:
            complete: True if all positions exist, False if some missing
            missing_tickets: Set of missing ticket IDs
            persisted_positions: All persisted positions
        """
        import time
        
        logger.warning("="*80)
        if complete:
            logger.warning("ðŸ“‹ RECOVERY OPTIONS:")
            logger.warning("  1. CONTINUE - Resume trading with existing positions")
            logger.warning("  2. CLOSE ALL - Close all positions and start fresh")
        else:
            logger.warning("ðŸ“‹ RECOVERY OPTIONS:")
            logger.warning("  1. REBALANCE - Reopen missing positions")
            logger.warning("  2. CLOSE ALL - Close all remaining positions")
        
        logger.warning("")
        logger.warning("â° Waiting 60 seconds for response...")
        logger.warning("ðŸ’¡ Use GUI or CLI to respond")
        logger.warning("â° If no response â†’ CLOSE ALL")
        logger.warning("="*80)
        
        # TODO: In production, this should be interactive
        # For now, we'll use a simple timeout
        response_received = False
        user_choice = None
        
        # Wait for 60 seconds (can be interrupted by user input)
        start_time = time.time()
        timeout = 60
        
        # For now, auto-close if incomplete, auto-continue if complete
        # In production, this should wait for actual user input
        if complete:
            logger.info("âœ… Setup complete - auto-continuing...")
            user_choice = 'continue'
            response_received = True
        else:
            logger.warning("âŒ Setup incomplete - auto-closing all...")
            user_choice = 'close_all'
            response_received = True
        
        # Process user choice
        if not response_received or user_choice == 'close_all':
            # Close all and clear flag
            logger.warning("ðŸ”´ CLOSING ALL POSITIONS...")
            self._close_all_positions()
            self.flag_manager.mark_setup_inactive("User declined recovery")
            return
        
        if user_choice == 'rebalance':
            # Rebalance missing positions
            logger.info("ðŸ”„ REBALANCING MISSING POSITIONS...")
            self._rebalance_missing_positions(missing_tickets, persisted_positions)
            return
        
        if user_choice == 'continue':
            # Restore positions to tracker
            logger.info("âœ… CONTINUING WITH EXISTING POSITIONS...")
            self._restore_positions_to_tracker(persisted_positions)
            return
    
    def _close_all_positions(self):
        """Close all open positions on MT5"""
        import MetaTrader5 as mt5
        
        positions = mt5.positions_get()
        if not positions:
            logger.info("No positions to close")
            return
        
        logger.info(f"Closing {len(positions)} position(s)...")
        
        for pos in positions:
            logger.info(f"Closing ticket {pos.ticket} ({pos.symbol})...")
            self.trade_executor.close_position(pos.ticket)
        
        # Clear tracker and monitor
        self.position_tracker.positions.clear()
        self.mt5_tickets.clear()
        self.position_monitor.clear_all()
        
        # Clear persisted data
        self.persistence.clear_all_positions()
        
        logger.info("âœ… All positions closed")
    
    def _rebalance_missing_positions(self, missing_tickets: set, persisted_positions: dict):
        """
        Rebalance missing positions
        
        Args:
            missing_tickets: Tickets that are missing
            persisted_positions: All persisted position data
        """
        logger.info("="*80)
        logger.info("ðŸ”„ REBALANCING MISSING POSITIONS")
        logger.info("="*80)
        
        # Find which positions are missing
        missing_positions = []
        remaining_positions = []
        
        for pos_id, pers_pos in persisted_positions.items():
            if pers_pos.mt5_ticket in missing_tickets:
                missing_positions.append(pers_pos)
            else:
                remaining_positions.append(pers_pos)
        
        logger.info(f"Missing: {len(missing_positions)} positions")
        logger.info(f"Remaining: {len(remaining_positions)} positions")
        
        # Check if it's a complete spread that's broken
        spreads = {}
        for pos in persisted_positions.values():
            spread_id = pos.spread_id
            if spread_id not in spreads:
                spreads[spread_id] = {'gold': None, 'silver': None}
            
            if pos.is_gold:
                spreads[spread_id]['gold'] = pos
            else:
                spreads[spread_id]['silver'] = pos
        
        # Check each spread
        for spread_id, legs in spreads.items():
            gold_pos = legs['gold']
            silver_pos = legs['silver']
            
            if not gold_pos or not silver_pos:
                logger.error(f"Spread {spread_id[:8]} incomplete in persistence!")
                continue
            
            gold_missing = gold_pos.mt5_ticket in missing_tickets
            silver_missing = silver_pos.mt5_ticket in missing_tickets
            
            if gold_missing and silver_missing:
                # BOTH missing - close spread completely
                logger.warning(f"Spread {spread_id[:8]} - BOTH legs missing")
                logger.warning("â†’ Marking as closed")
                self.persistence.archive_spread(spread_id, reason="both_legs_manually_closed")
                continue
            
            if gold_missing or silver_missing:
                # ONE leg missing - this is dangerous!
                logger.error(f"Spread {spread_id[:8]} - ONE leg missing!")
                
                if gold_missing:
                    logger.error(f"  âŒ Gold position missing (Ticket: {gold_pos.mt5_ticket})")
                    logger.error(f"  âœ… Silver position exists (Ticket: {silver_pos.mt5_ticket})")
                    logger.error("  â†’ CLOSING remaining silver position to avoid unhedged risk")
                    
                    # Close the remaining silver position
                    try:
                        result = self.trade_executor.close_position(silver_pos.mt5_ticket)
                        if result.success:
                            logger.info(f"  âœ… Closed silver position {silver_pos.mt5_ticket}")
                        else:
                            logger.error(f"  âŒ Failed to close silver: {result.comment}")
                    except Exception as e:
                        logger.error(f"  âŒ Error closing silver: {e}")
                
                else:  # silver_missing
                    logger.error(f"  âœ… Gold position exists (Ticket: {gold_pos.mt5_ticket})")
                    logger.error(f"  âŒ Silver position missing (Ticket: {silver_pos.mt5_ticket})")
                    logger.error("  â†’ CLOSING remaining gold position to avoid unhedged risk")
                    
                    # Close the remaining gold position
                    try:
                        result = self.trade_executor.close_position(gold_pos.mt5_ticket)
                        if result.success:
                            logger.info(f"  âœ… Closed gold position {gold_pos.mt5_ticket}")
                        else:
                            logger.error(f"  âŒ Failed to close gold: {result.comment}")
                    except Exception as e:
                        logger.error(f"  âŒ Error closing gold: {e}")
                
                # Archive the spread
                self.persistence.archive_spread(spread_id, reason="partial_spread_detected")
        
        # Clear all state
        self.position_tracker.positions.clear()
        self.mt5_tickets.clear()
        self.position_monitor.clear_all()
        self.persistence.clear_all_positions()
        self.flag_manager.mark_setup_inactive("Rebalance completed - all closed")
        
        logger.info("="*80)
        logger.info("âœ… Rebalancing complete - all positions closed for safety")
        logger.info("="*80)
    
    def _restore_positions_to_tracker(self, persisted_positions: dict):
        """
        Restore positions to tracker and monitoring
        
        Args:
            persisted_positions: All persisted position data
        """
        from strategy.position_tracker import Position
        
        # Group by spread_id
        spreads = {}
        for pos_id, pers_pos in persisted_positions.items():
            spread_id = pers_pos.spread_id
            if spread_id not in spreads:
                spreads[spread_id] = []
            spreads[spread_id].append(pers_pos)
        
        # Restore each spread
        recovered = 0
        for spread_id, positions in spreads.items():
            try:
                # Restore positions to tracker
                for pers_pos in positions:
                    position = Position(
                        position_id=pers_pos.position_id,
                        symbol=pers_pos.symbol,
                        side=pers_pos.side,
                        quantity=pers_pos.volume,
                        entry_price=pers_pos.entry_price,
                        current_price=pers_pos.entry_price,
                        metadata={
                            'spread_id': pers_pos.spread_id,
                            'entry_zscore': pers_pos.entry_zscore,
                            'hedge_ratio': pers_pos.hedge_ratio,
                            'recovered': True
                        }
                    )
                    
                    self.position_tracker.positions[pers_pos.position_id] = position
                    
                    # Map MT5 ticket
                    self.mt5_tickets[pers_pos.position_id] = pers_pos.mt5_ticket
                    
                    # Register with monitor
                    self.position_monitor.register_position(
                        ticket=pers_pos.mt5_ticket,
                        symbol=pers_pos.symbol
                    )
                    
                    logger.info(f"âœ“ Recovered: {pers_pos.symbol} {pers_pos.side} "
                               f"{pers_pos.volume} lots @ {pers_pos.entry_price:.2f} "
                               f"(Ticket: {pers_pos.mt5_ticket})")
                    
                    recovered += 1
                
                # Register spread with rebalancer
                if len(positions) == 2:
                    first_pos = positions[0]
                    gold_pos = positions[0] if 'XAU' in positions[0].symbol else positions[1]
                    silver_pos = positions[1] if gold_pos == positions[0] else positions[0]
                    
                    self.rebalancer.register_position(
                        spread_id=spread_id,
                        side=first_pos.side,
                        entry_zscore=first_pos.entry_zscore,
                        entry_hedge_ratio=first_pos.hedge_ratio,  # Direct field, not metadata
                        gold_lots=gold_pos.volume,
                        silver_lots=silver_pos.volume,
                        total_position_size=gold_pos.volume
                    )
                    
                    # Register with attribution engine using MT5 comment
                    # Query MT5 to get actual comment
                    import MetaTrader5 as mt5
                    mt5_pos = None
                    for pos in mt5.positions_get():
                        if pos.ticket == gold_pos.mt5_ticket:
                            mt5_pos = pos
                            break
                    
                    if mt5_pos and mt5_pos.comment:
                        # Use MT5 comment as spread_id for attribution
                        mt5_spread_id = mt5_pos.comment
                        
                        try:
                            from analytics.pnl_attribution import get_attribution_engine, PositionSnapshot
                            from datetime import datetime
                            
                            # Create entry snapshot from persisted data
                            entry_snapshot = PositionSnapshot(
                                timestamp=datetime.fromisoformat(gold_pos.entry_time),
                                xau_bid=gold_pos.entry_price,
                                xau_ask=gold_pos.entry_price,
                                xag_bid=silver_pos.entry_price,
                                xag_ask=silver_pos.entry_price,
                                spread=0.0,  # Will be recalculated
                                mean=0.0,
                                std=0.0,
                                zscore=gold_pos.entry_zscore,
                                hedge_ratio=gold_pos.hedge_ratio,
                                xau_volume=gold_pos.volume,
                                xag_volume=silver_pos.volume,
                                xau_side=gold_pos.side,
                                xag_side=silver_pos.side,
                                xau_price=gold_pos.entry_price,
                                xag_price=silver_pos.entry_price
                            )
                            
                            attribution_engine = get_attribution_engine()
                            attribution_engine.register_position(mt5_spread_id, entry_snapshot)
                            logger.info(f"âœ… Registered {mt5_spread_id} in attribution engine (recovered)")
                        except Exception as e:
                            logger.error(f"Failed to register attribution for recovered spread: {e}")
                
            except Exception as e:
                logger.error(f"Failed to recover spread {spread_id}: {e}")
                import traceback
                traceback.print_exc()
        
        logger.info("="*80)
        logger.info(f"POSITION RECOVERY COMPLETE: {recovered} positions recovered")
        logger.info("="*80)
    
    def _handle_missing_positions(self, missing_tickets: set):
        """
        Handle missing positions detected during runtime
        
        Args:
            missing_tickets: Set of missing MT5 tickets
        """
        logger.error(f"ðŸš¨ Position monitor detected {len(missing_tickets)} missing position(s)")
        
        # Check if ALL positions are missing
        all_tickets = self.position_monitor.get_monitored_tickets()
        all_missing = (missing_tickets == all_tickets)
        
        if all_missing:
            logger.error("="*80)
            logger.error("ðŸš¨ ALL POSITIONS CLOSED MANUALLY!")
            logger.error("="*80)
            logger.error("All tracked positions have been closed on MT5")
            logger.error("This likely means user closed everything manually")
        
        # Unregister from monitor
        for ticket in missing_tickets:
            self.position_monitor.unregister_position(ticket)
        
        # Note: User confirmation is handled by PositionMonitor
        # This callback is just for logging/tracking
    
    def _handle_user_rebalance(self, missing_tickets: set):
        """
        Handle user confirmation to rebalance
        
        Args:
            missing_tickets: Set of missing MT5 tickets
        """
        logger.info("âœ… User confirmed: REBALANCE")
        logger.info("ðŸ”„ Rebalancing not yet implemented - closing all instead")
        self._emergency_close_all()
    
    def _handle_user_timeout(self):
        """Handle user timeout - close all positions"""
        logger.error("âŒ User timeout or declined - CLOSING ALL POSITIONS")
        self._emergency_close_all()
    
    def _emergency_close_all(self):
        """Emergency close all positions"""
        import MetaTrader5 as mt5
        
        logger.error("ðŸš¨ EMERGENCY CLOSE - Closing all positions...")
        
        positions = mt5.positions_get()
        if positions:
            for pos in positions:
                logger.info(f"Closing ticket {pos.ticket}...")
                self.trade_executor.close_position(pos.ticket)
        
        # Clear all state
        self.position_tracker.positions.clear()
        self.mt5_tickets.clear()
        self.position_monitor.clear_all()
        self.persistence.clear_all_positions()
        self.flag_manager.mark_setup_inactive("Emergency close")
        
        logger.error("âœ… Emergency close complete")
    
    def start(self):
        """Start all threads"""
        if self.running:
            return
        
        self.running = True
        logger.info("Starting system...")
        
        # RECOVER POSITIONS FROM DISK (if any)
        self._recover_positions()
        
        # START POSITION MONITOR
        self.position_monitor.start()
        
        threads_config = [
            ("Data", self._data_thread),
            ("Signal", self._signal_thread),
            ("Execution", self._execution_thread),
            ("Monitor", self._monitor_thread),
            ("Attribution", self._attribution_thread),
        ]
        
        for name, target in threads_config:
            thread = threading.Thread(target=target, name=name, daemon=True)
            thread.start()
            self.threads.append(thread)
            logger.info(f"Started {name} thread")
        
        logger.info("All threads started")
    
    def stop(self):
        """Stop all threads"""
        logger.info("Stopping system...")
        self.running = False
        
        # Stop position monitor
        self.position_monitor.stop()
        
        for thread in self.threads:
            thread.join(timeout=5)
        
        self.data_manager.connector.shutdown()
        self.trade_executor.shutdown()
        logger.info("System stopped")
    
    def _data_thread(self):
        """Data fetching thread - TRUE ROLLING WINDOW"""
        logger.info("Data thread started")
        
        # Bootstrap rolling window ONCE at startup
        logger.info("Bootstrapping rolling window with historical data...")
        try:
            self.market_data.bootstrap_window(days=30)
            logger.info("Rolling window ready - starting real-time updates")
            
            # Get IMMEDIATE first snapshot (don't wait for update_interval)
            logger.info("Fetching initial snapshot...")
            initial_snapshot = self.market_data.get_realtime_snapshot()
            
            if initial_snapshot:
                self.current_snapshot = initial_snapshot
                logger.info(f"Initial snapshot ready - Z-Score: {initial_snapshot.zscore:.3f}")
            else:
                logger.error("Failed to get initial snapshot!")
        
        except Exception as e:
            logger.error(f"Bootstrap failed: {e}")
            import traceback
            traceback.print_exc()
            # Continue anyway, maybe MT5 will connect later
        
        while self.running:
            try:
                # Get real-time snapshot
                # This updates current H1 bar's close and recalculates stats
                snapshot = self.market_data.get_realtime_snapshot()
                
                if snapshot is None:
                    logger.error("Failed to get market snapshot")
                    time.sleep(10)
                    continue
                
                # Get volatility
                primary_vol, secondary_vol = self.market_data.get_volatility()
                
                # Package data for other threads
                data = {
                    'timestamp': snapshot.timestamp,
                    'snapshot': snapshot,
                    'current_primary_price': snapshot.primary_bid,
                    'current_secondary_price': snapshot.secondary_bid,
                    'current_zscore': snapshot.zscore,
                    'primary_vol': primary_vol,
                    'secondary_vol': secondary_vol
                }
                
                # Push to queue
                try:
                    self.data_queue.put(data, block=False)
                    logger.debug(f"Rolling update: {snapshot}")
                    logger.debug(f"  Mean: {snapshot.spread_mean:.2f}, Std: {snapshot.spread_std:.2f}")
                except queue.Full:
                    logger.warning("Data queue full")
                
                self.last_update_time = datetime.now()
                self.current_snapshot = snapshot
                
                # ========== CRITICAL: SYNC WITH MT5 REAL BALANCE ==========
                try:
                    import MetaTrader5 as mt5
                    mt5_info = mt5.account_info()
                    
                    if mt5_info:
                        # Get REAL balance and equity from MT5
                        mt5_balance = mt5_info.balance
                        mt5_equity = mt5_info.equity
                        mt5_profit = mt5_info.profit  # Current unrealized P&L
                        
                        # Calculate drift between internal and MT5
                        balance_drift = abs(self.account_balance - mt5_balance)
                        
                        if balance_drift > 100:  # $100 drift warning
                            logger.warning(f"âš ï¸  Balance drift detected: "
                                         f"Internal=${self.account_balance:,.2f}, "
                                         f"MT5=${mt5_balance:,.2f}, "
                                         f"Drift=${balance_drift:,.2f}")
                        
                        # Update drawdown monitor with REAL MT5 equity
                        # This is CRITICAL for accurate risk management!
                        self.drawdown_monitor.update(mt5_equity)
                        
                        # Update risk checker with real balance
                        if hasattr(self, 'position_sizer'):
                            self.position_sizer.update_balance(mt5_balance)
                        
                        # Log MT5 real data
                        logger.debug(f"MT5 Real Data: Balance=${mt5_balance:,.2f}, "
                                   f"Equity=${mt5_equity:,.2f}, "
                                   f"Unrealized P&L=${mt5_profit:,.2f}")
                        
                        # Check drawdown limits on REAL equity
                        dd_metrics = self.drawdown_monitor.get_metrics()
                        if dd_metrics.current_drawdown_pct > self.max_drawdown_limit:
                            logger.critical(f"ðŸš¨ REAL DRAWDOWN LIMIT EXCEEDED!")
                            logger.critical(f"   Current DD: {dd_metrics.current_drawdown_pct:.2%}")
                            logger.critical(f"   Limit: {self.max_drawdown_limit:.2%}")
                            logger.critical(f"   MT5 Equity: ${mt5_equity:,.2f}")
                            logger.critical(f"   Stopping system for safety!")
                            self.stop()
                            break
                    else:
                        logger.warning("Failed to get MT5 account info")
                        
                except Exception as e:
                    logger.error(f"MT5 sync error: {e}")
                # ========== END MT5 SYNC ==========
                
                # Sleep
                time.sleep(self.update_interval)
                
            except Exception as e:
                logger.error(f"Data thread error: {e}")
                import traceback
                traceback.print_exc()
                time.sleep(10)
    
    def _signal_thread(self):
        """Signal generation thread"""
        logger.info("Signal thread started")
        
        while self.running:
            try:
                data = self.data_queue.get(timeout=5)
                
                with self.lock:
                    snapshot = data['snapshot']
                    
                    open_positions = self.position_tracker.get_all_positions()
                    current_position = None
                    
                    if open_positions:
                        gold_positions = [p for p in open_positions if p.symbol == 'XAUUSD']
                        if gold_positions:
                            current_position = 'LONG' if gold_positions[0].side == 'LONG' else 'SHORT'
                    
                    # Generate signal
                    signal = self.signal_generator.generate_signal(
                        primary_price=snapshot.primary_bid,
                        secondary_price=snapshot.secondary_bid,
                        zscore=snapshot.zscore,
                        hedge_ratio=snapshot.hedge_ratio,
                        current_position=current_position
                    )
                    
                    self.current_signal = signal
                    
                    # Track z-score changes
                    self.zscore_monitor.add(signal.zscore)
                    
                    # Log z-score with more detail
                    zscore_status = self.zscore_monitor.format_status()
                    logger.info(f"[MARKET] {zscore_status}")
                    logger.info(f"         Primary: ${snapshot.primary_bid:.2f} | "
                               f"Secondary: ${snapshot.secondary_bid:.4f} | "
                               f"Signal: {signal.signal_type.value} | "
                               f"Window: {snapshot.window_size} bars")
                    
                    # Alert on significant z-score changes
                    if self.zscore_monitor.should_alert(threshold=0.3):
                        change = self.zscore_monitor.get_change()
                        logger.warning(f"[ALERT] Significant z-score change: {change:+.3f}")
                    
                    # CHECK REBALANCING (BOTH PYRAMIDING AND HEDGE DRIFT)
                    if open_positions:
                        # Get current hedge ratio
                        current_hedge_ratio = snapshot.hedge_ratio
                        
                        # Check all rebalancing needs
                        pyramid_actions, hedge_adjustments = self.rebalancer.check_all_rebalancing(
                            current_zscore=snapshot.zscore,
                            current_hedge_ratio=current_hedge_ratio
                        )
                        
                        # Queue pyramiding actions
                        for action in pyramid_actions:
                            logger.info(f"[PYRAMIDING] {action['reason']}")
                            try:
                                self.signal_queue.put({
                                    'signal': signal,
                                    'data': data,
                                    'rebalance': action
                                }, block=False)
                            except queue.Full:
                                logger.warning("Signal queue full")
                        
                        # Queue hedge adjustments
                        for adjustment in hedge_adjustments:
                            logger.info(f"[HEDGE ADJUSTMENT] {adjustment.reason}")
                            try:
                                self.signal_queue.put({
                                    'signal': signal,
                                    'data': data,
                                    'hedge_adjustment': adjustment
                                }, block=False)
                            except queue.Full:
                                logger.warning("Signal queue full")
                    
                    # Normal signal processing
                    if signal.signal_type != SignalType.HOLD:
                        try:
                            self.signal_queue.put({
                                'signal': signal, 
                                'data': data,
                                'rebalance': None
                            }, block=False)
                        except queue.Full:
                            logger.warning("Signal queue full")
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Signal thread error: {e}")
                import traceback
                traceback.print_exc()
                time.sleep(5)
    
    def _execution_thread(self):
        """Execution thread"""
        logger.info("Execution thread started")
        
        while self.running:
            try:
                signal_data = self.signal_queue.get(timeout=5)
                signal = signal_data['signal']
                data = signal_data['data']
                rebalance = signal_data.get('rebalance')
                hedge_adjustment = signal_data.get('hedge_adjustment')
                
                with self.lock:
                    # Handle pyramiding
                    if rebalance and rebalance.get('type') == 'PYRAMIDING':
                        self._execute_pyramiding(rebalance, data)
                        continue
                    
                    # Handle hedge adjustment
                    if hedge_adjustment:
                        self._execute_hedge_adjustment(hedge_adjustment, data)
                        continue
                    
                    # Check signal type
                    is_entry = signal.signal_type in [SignalType.LONG_SPREAD, SignalType.SHORT_SPREAD]
                    is_exit = signal.signal_type in [SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT]
                    
                    # CRITICAL: Allow CLOSE signals even if max positions reached!
                    if is_exit:
                        # Always process exit signals
                        self._execute_exit(signal, data)
                        continue
                    
                    # Max position check ONLY for entry signals
                    if is_entry and len(self.position_tracker.positions) >= self.max_positions:
                        logger.warning(f"Max positions ({self.max_positions}) reached - blocking new entries")
                        continue
                    
                    # Get volatility from market_data
                    primary_vol, secondary_vol = self.market_data.get_volatility()
                    
                    # Calculate position size
                    pos_size_result = self.position_sizer.calculate_optimal(
                        win_rate=0.55,
                        avg_win=150,
                        avg_loss=100,
                        volatility=primary_vol
                    )
                    
                    # Get drawdown metrics
                    dd_metrics = self.drawdown_monitor.get_metrics()
                    
                    # Get current prices
                    snapshot = data['snapshot']
                    
                    # Risk check
                    risk_result = self.risk_checker.check_trade(
                        position_size=pos_size_result.position_size,
                        account_balance=self.account_balance,
                        current_drawdown=dd_metrics.current_drawdown_pct,
                        entry_price=snapshot.primary_bid,
                        stop_loss=snapshot.primary_bid * 0.98,
                        take_profit=snapshot.primary_bid * 1.02,
                        existing_positions=len(self.position_tracker.positions)
                    )
                    
                    if not risk_result.passed:
                        failed_checks = ", ".join(risk_result.checks_failed)
                        logger.warning(f"Risk check FAILED: {failed_checks}")
                        continue
                    
                    # Execute based on signal
                    if signal.signal_type in [SignalType.LONG_SPREAD, SignalType.SHORT_SPREAD]:
                        self._execute_entry(signal, data, pos_size_result)
                    elif signal.signal_type in [SignalType.CLOSE_LONG, SignalType.CLOSE_SHORT]:
                        self._execute_exit(signal, data)
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"Execution thread error: {e}")
                import traceback
                traceback.print_exc()
                time.sleep(5)
    
    def _execute_entry(self, signal, data, pos_size_result):
        """Execute spread entry with REAL-TIME hedge calculation"""
        try:
            # Calculate Primary position size
            gold_value = self.account_balance * pos_size_result.position_size
            gold_quantity = gold_value / data['current_primary_price'] / 100
            
            # Use real-time hedge calculation
            gold_lots, silver_lots = self.market_data.calculate_hedge_quantities(gold_quantity)
            
            side = 'LONG' if signal.signal_type == SignalType.LONG_SPREAD else 'SHORT'
            
            snapshot = data['snapshot']
            
            logger.info(f"=== EXECUTING {side} SPREAD (REAL-TIME) ===")
            logger.info(f"Market: Primary ${snapshot.primary_bid:.2f}, Secondary ${snapshot.secondary_bid:.4f}")
            logger.info(f"Z-Score: {snapshot.zscore:.3f}")
            logger.info(f"Hedge Ratio: {snapshot.hedge_ratio:.4f}")
            logger.info(f"Position: Primary {gold_lots:.4f} lots, Secondary {silver_lots:.4f} lots")
            
            # EXECUTE REAL ORDERS with attribution tracking
            (gold_result, silver_result), spread_id, returned_zscore = self.trade_executor.place_spread_orders(
                gold_volume=gold_lots,
                silver_volume=silver_lots,
                side=side,
                entry_zscore=snapshot.zscore
            )
            
            # Use returned zscore (should match snapshot.zscore)
            entry_zscore = returned_zscore if returned_zscore is not None else snapshot.zscore
            
            if not gold_result.success or not silver_result.success:
                logger.error(f"Trade execution FAILED!")
                if not gold_result.success:
                    logger.error(f"  Primary: {gold_result.comment}")
                if not silver_result.success:
                    logger.error(f"  Secondary: {silver_result.comment}")
                return
            
            logger.info(f"[MT5 SUCCESS] Spread {spread_id} filled:")
            logger.info(f"  Primary: {gold_result.volume} lots @ ${gold_result.price:.2f} (Ticket {gold_result.order_ticket})")
            logger.info(f"  Secondary: {silver_result.volume} lots @ ${silver_result.price:.4f} (Ticket {silver_result.order_ticket})")
            
            # Register in attribution engine
            try:
                from analytics.pnl_attribution import get_attribution_engine, PositionSnapshot
                from datetime import datetime
                
                entry_snapshot = PositionSnapshot(
                    timestamp=datetime.now(),
                    xau_bid=snapshot.primary_bid,
                    xau_ask=snapshot.primary_ask,
                    xag_bid=snapshot.secondary_bid,
                    xag_ask=snapshot.secondary_ask,
                    spread=snapshot.spread,
                    mean=snapshot.spread_mean,
                    std=snapshot.spread_std,
                    zscore=entry_zscore,  # Use returned zscore, not snapshot
                    hedge_ratio=snapshot.hedge_ratio,
                    xau_volume=gold_result.volume,
                    xag_volume=silver_result.volume,
                    xau_side='LONG' if side == 'LONG' else 'SHORT',
                    xag_side='SHORT' if side == 'LONG' else 'LONG',
                    xau_price=gold_result.price,
                    xag_price=silver_result.price
                )
                
                attribution_engine = get_attribution_engine()
                attribution_engine.register_position(spread_id, entry_snapshot)
                logger.info(f"âœ… Registered {spread_id} in attribution engine")
            except Exception as e:
                logger.error(f"Failed to register attribution: {e}")
            
            # Update order manager
            gold_order, silver_order = self.order_manager.create_spread_orders(
                gold_result.volume, silver_result.volume, side
            )
            
            self.order_manager.update_order_status(
                gold_order.order_id, OrderStatus.FILLED,
                gold_result.volume, gold_result.price
            )
            
            self.order_manager.update_order_status(
                silver_order.order_id, OrderStatus.FILLED,
                silver_result.volume, silver_result.price
            )
            
            # Open positions in tracker (will generate internal UUID)
            gold_pos, silver_pos = self.position_tracker.open_spread_position(
                gold_result.volume, silver_result.volume,
                gold_result.price, silver_result.price,
                side, snapshot.hedge_ratio
            )
            
            # IMPORTANT: Override tracker's UUID spread_id with ticket-based spread_id
            # This ensures consistency across all systems
            gold_pos.metadata['spread_id'] = spread_id  # Use ticket-based!
            silver_pos.metadata['spread_id'] = spread_id  # Use ticket-based!
            
            # Map to MT5 tickets
            self.mt5_tickets[gold_pos.position_id] = gold_result.order_ticket
            self.mt5_tickets[silver_pos.position_id] = silver_result.order_ticket
            
            # SAVE POSITIONS TO DISK (for crash recovery)
            from core.position_persistence import PersistedPosition
            from datetime import datetime
            
            # Use ticket-based spread_id (already in variable from place_spread_orders)
            # Save gold position
            gold_persisted = PersistedPosition(
                position_id=gold_pos.position_id,
                spread_id=spread_id,
                mt5_ticket=gold_result.order_ticket,
                symbol='XAUUSD',
                side=gold_pos.side,
                volume=gold_pos.quantity,  # Position uses 'quantity' not 'volume'
                entry_price=gold_pos.entry_price,
                entry_time=str(gold_pos.opened_at),  # Convert datetime to string
                entry_zscore=entry_zscore,  # Use returned zscore
                hedge_ratio=snapshot.hedge_ratio,
                is_gold=True,
                created_at=datetime.now().isoformat(),
                last_updated=datetime.now().isoformat()
            )
            self.persistence.save_position(gold_persisted)
            
            # Save silver position
            silver_persisted = PersistedPosition(
                position_id=silver_pos.position_id,
                spread_id=spread_id,
                mt5_ticket=silver_result.order_ticket,
                symbol='XAGUSD',
                side=silver_pos.side,
                volume=silver_pos.quantity,  # Position uses 'quantity' not 'volume'
                entry_price=silver_pos.entry_price,
                entry_time=str(silver_pos.opened_at),  # Convert datetime to string
                entry_zscore=entry_zscore,  # Use returned zscore
                hedge_ratio=snapshot.hedge_ratio,
                is_gold=False,
                created_at=datetime.now().isoformat(),
                last_updated=datetime.now().isoformat()
            )
            self.persistence.save_position(silver_persisted)
            
            logger.info(f"[PERSISTENCE] Spread {spread_id[:8]} saved to disk")
            
            # SET ACTIVE SETUP FLAG (first position opened)
            if not self.flag_manager.is_setup_active():
                self.flag_manager.mark_setup_active(
                    spread_id=spread_id,
                    metadata={
                        'side': side,
                        'entry_zscore': entry_zscore,  # Use returned zscore
                        'hedge_ratio': snapshot.hedge_ratio,
                        'gold_lots': gold_result.volume,
                        'silver_lots': silver_result.volume
                    }
                )
                logger.info(f"âœ… Setup flag: ACTIVE")
            
            # REGISTER WITH POSITION MONITOR
            self.position_monitor.register_position(
                ticket=gold_result.order_ticket,
                symbol='XAUUSD'
            )
            self.position_monitor.register_position(
                ticket=silver_result.order_ticket,
                symbol='XAGUSD'
            )
            
            # Register with rebalancer (hybrid - pyramiding + hedge adjustment)
            if spread_id:
                self.rebalancer.register_position(
                    spread_id=spread_id,
                    side=side,
                    entry_zscore=snapshot.zscore,
                    entry_hedge_ratio=snapshot.hedge_ratio,
                    gold_lots=gold_result.volume,
                    silver_lots=silver_result.volume,
                    total_position_size=pos_size_result.position_size
                )
                logger.info(f"[HYBRID REBALANCER] Position registered")
                logger.info(f"  Pyramiding: Enabled")
                logger.info(f"  Hedge adjustment: {'Enabled' if self.rebalancer.enable_hedge_adjustment else 'Disabled'}")
            
            logger.info(f"[SUCCESS] {side} SPREAD opened")
            
        except Exception as e:
            logger.error(f"Entry error: {e}")
            import traceback
            traceback.print_exc()
            
        except Exception as e:
            logger.info(f"Entry error: {e}")
            import traceback
            traceback.print_exc()
    
    def _execute_pyramiding(self, rebalance, data):
        """Execute rebalancing (scale into position)"""
        try:
            spread_id = rebalance['spread_id']
            side = rebalance['side']
            level = rebalance['level']
            position_size = rebalance['position_size']
            
            snapshot = data['snapshot']
            
            logger.info(f"[REBALANCE] Scaling into position {spread_id[:8]}")
            logger.info(f"  Z-score: {snapshot.zscore:.2f} â†’ trigger: {level.zscore:.2f}")
            logger.info(f"  Adding: {position_size:.2%} of total position")
            
            # Calculate additional quantities
            gold_value = self.account_balance * position_size
            gold_quantity = gold_value / snapshot.primary_bid / 100
            
            # Use real-time hedge calculation
            gold_lots, silver_lots = self.market_data.calculate_hedge_quantities(gold_quantity)
            
            logger.info(f"  Primary: +{gold_lots:.4f} lots")
            logger.info(f"  Secondary: +{silver_lots:.4f} lots")
            
            # Execute orders with attribution tracking
            (gold_result, silver_result), new_spread_id = self.trade_executor.place_spread_orders(
                gold_volume=gold_lots,
                silver_volume=silver_lots,
                side=side,
                entry_zscore=snapshot.zscore
            )
            
            if not gold_result.success or not silver_result.success:
                logger.error(f"Rebalance execution FAILED!")
                return
            
            logger.info(f"[MT5 SUCCESS] Rebalance orders filled:")
            logger.info(f"  Primary: {gold_result.volume} lots @ ${gold_result.price:.2f}")
            logger.info(f"  Secondary: {silver_result.volume} lots @ ${silver_result.price:.4f}")
            
            # Mark level as executed
            self.rebalancer.mark_pyramiding_executed(
                spread_id=spread_id,
                zscore=level.zscore,
                gold_lots=gold_result.volume,
                silver_lots=silver_result.volume
            )
            
            # Add to existing positions
            gold_pos, silver_pos = self.position_tracker.open_spread_position(
                gold_result.volume, silver_result.volume,
                gold_result.price, silver_result.price,
                side, snapshot.hedge_ratio
            )
            
            # Link to original spread
            gold_pos.metadata['spread_id'] = spread_id
            silver_pos.metadata['spread_id'] = spread_id
            
            # Map to MT5 tickets
            self.mt5_tickets[gold_pos.position_id] = gold_result.order_ticket
            self.mt5_tickets[silver_pos.position_id] = silver_result.order_ticket
            
            logger.info(f"[SUCCESS] Rebalanced position {spread_id[:8]}")
            
        except Exception as e:
            logger.error(f"Rebalance error: {e}")
            import traceback
            traceback.print_exc()
    
    def _execute_hedge_adjustment(self, adjustment, data):
        """
        Execute hedge adjustment to maintain dollar neutrality
        
        Args:
            adjustment: HedgeAdjustment dataclass
            data: Market data
        """
        try:
            spread_id = adjustment.spread_id
            
            logger.info(f"[HEDGE ADJUSTMENT] Adjusting position {spread_id[:8]}")
            logger.info(f"  Reason: {adjustment.reason}")
            logger.info(f"  Old hedge: {adjustment.old_hedge:.4f}")
            logger.info(f"  New hedge: {adjustment.new_hedge:.4f}")
            logger.info(f"  Action: {adjustment.action} {adjustment.quantity:.4f} lots {adjustment.symbol}")
            
            # Execute adjustment order (only Secondary side)
            if adjustment.action == 'BUY':
                result = self.trade_executor.place_order(
                    symbol=adjustment.symbol,
                    volume=adjustment.quantity,
                    side='BUY'
                )
            else:  # SELL
                result = self.trade_executor.place_order(
                    symbol=adjustment.symbol,
                    volume=adjustment.quantity,
                    side='SELL'
                )
            
            if not result.success:
                logger.error(f"Hedge adjustment FAILED: {result.comment}")
                return
            
            logger.info(f"[MT5 SUCCESS] Hedge adjustment executed:")
            logger.info(f"  {result.volume} lots @ ${result.price:.4f} (Ticket {result.order_ticket})")
            
            # Update rebalancer
            self.rebalancer.mark_hedge_adjusted(
                spread_id=spread_id,
                adjustment=adjustment,
                executed_quantity=result.volume
            )
            
            # Find and update position tracker
            # Note: This is a partial position adjustment, not a full spread
            # We just adjust the silver side
            positions = [p for p in self.position_tracker.get_all_positions() 
                        if p.metadata.get('spread_id') == spread_id and p.symbol == adjustment.symbol]
            
            if positions:
                # Update first matching position's volume
                # In production, you might want more sophisticated tracking
                position = positions[0]
                
                if adjustment.action == 'BUY':
                    # Add to existing position
                    # Create new mini-position or adjust existing
                    logger.info(f"  Updated {position.symbol} position")
                else:
                    # Reduce existing position
                    logger.info(f"  Reduced {position.symbol} position")
            
            logger.info(f"[SUCCESS] Hedge adjustment complete")
            
        except Exception as e:
            logger.error(f"Hedge adjustment error: {e}")
            import traceback
            traceback.print_exc()
    
    def _execute_exit(self, signal, data):
        """Execute spread exit with REAL MT5 closing"""
        try:
            positions = self.position_tracker.get_all_positions()
            
            if not positions:
                return
            
            spread_ids = set()
            for pos in positions:
                if 'spread_id' in pos.metadata:
                    spread_ids.add(pos.metadata['spread_id'])
            
            for spread_id in spread_ids:
                logger.info(f"Closing spread {spread_id[:8]} on MT5...")
                
                # Find primary and secondary positions
                spread_positions = [p for p in positions if p.metadata.get('spread_id') == spread_id]
                gold_pos = next((p for p in spread_positions if p.symbol == 'XAUUSD'), None)
                silver_pos = next((p for p in spread_positions if p.symbol == 'XAGUSD'), None)
                
                if not gold_pos or not silver_pos:
                    logger.error(f"Incomplete spread {spread_id[:8]}")
                    continue
                
                # Get MT5 tickets
                primary_ticket = self.mt5_tickets.get(gold_pos.position_id)
                secondary_ticket = self.mt5_tickets.get(silver_pos.position_id)
                
                if not primary_ticket or not secondary_ticket:
                    logger.error(f"MT5 tickets not found for spread {spread_id[:8]}")
                    continue
                
                # CLOSE REAL POSITIONS ON MT5
                gold_result, silver_result = self.trade_executor.close_spread_positions(
                    gold_ticket=primary_ticket,
                    silver_ticket=secondary_ticket
                )
                
                # Handle partial close failures
                gold_closed = gold_result.success
                silver_closed = silver_result.success
                
                if not gold_closed or not silver_closed:
                    logger.error("="*80)
                    logger.error("âš ï¸  PARTIAL CLOSE FAILURE!")
                    logger.error("="*80)
                    
                    if not gold_closed:
                        logger.error(f"âŒ Gold close FAILED: {gold_result.comment}")
                    else:
                        logger.info(f"âœ… Gold closed: {primary_ticket}")
                    
                    if not silver_closed:
                        logger.error(f"âŒ Silver close FAILED: {silver_result.comment}")
                    else:
                        logger.info(f"âœ… Silver closed: {secondary_ticket}")
                    
                    # Handle each leg independently
                    if gold_closed:
                        # Gold closed successfully - cleanup its state
                        logger.info("Cleaning up gold position state...")
                        self.position_monitor.unregister_position(primary_ticket)
                        if gold_pos.position_id in self.mt5_tickets:
                            del self.mt5_tickets[gold_pos.position_id]
                        
                        # Remove gold from tracker
                        if gold_pos.position_id in self.position_tracker.positions:
                            del self.position_tracker.positions[gold_pos.position_id]
                        
                        # Archive gold position
                        self.persistence.delete_position(gold_pos.position_id)
                    
                    if silver_closed:
                        # Silver closed successfully - cleanup its state
                        logger.info("Cleaning up silver position state...")
                        self.position_monitor.unregister_position(secondary_ticket)
                        if silver_pos.position_id in self.mt5_tickets:
                            del self.mt5_tickets[silver_pos.position_id]
                        
                        # Remove silver from tracker
                        if silver_pos.position_id in self.position_tracker.positions:
                            del self.position_tracker.positions[silver_pos.position_id]
                        
                        # Archive silver position
                        self.persistence.delete_position(silver_pos.position_id)
                    
                    # If one leg closed but other failed - DANGEROUS STATE!
                    if gold_closed != silver_closed:
                        logger.error("="*80)
                        logger.error("ðŸš¨ CRITICAL: UNHEDGED POSITION!")
                        logger.error("="*80)
                        logger.error("One leg closed, other leg failed to close")
                        logger.error("Position is now UNHEDGED - manual intervention required!")
                        logger.error("="*80)
                        
                        # Try to close the remaining leg again
                        remaining_ticket = secondary_ticket if gold_closed else primary_ticket
                        remaining_symbol = "SILVER" if gold_closed else "GOLD"
                        
                        logger.warning(f"Attempting to close remaining {remaining_symbol} position...")
                        try:
                            retry_result = self.trade_executor.close_position(remaining_ticket)
                            if retry_result.success:
                                logger.info(f"âœ… Retry successful - {remaining_symbol} closed")
                                
                                # Cleanup the remaining position
                                if gold_closed:  # silver was remaining
                                    self.position_monitor.unregister_position(secondary_ticket)
                                    if silver_pos.position_id in self.mt5_tickets:
                                        del self.mt5_tickets[silver_pos.position_id]
                                    if silver_pos.position_id in self.position_tracker.positions:
                                        del self.position_tracker.positions[silver_pos.position_id]
                                    self.persistence.delete_position(silver_pos.position_id)
                                else:  # gold was remaining
                                    self.position_monitor.unregister_position(primary_ticket)
                                    if gold_pos.position_id in self.mt5_tickets:
                                        del self.mt5_tickets[gold_pos.position_id]
                                    if gold_pos.position_id in self.position_tracker.positions:
                                        del self.position_tracker.positions[gold_pos.position_id]
                                    self.persistence.delete_position(gold_pos.position_id)
                                
                                # Both closed now - archive spread
                                self.persistence.archive_spread(spread_id, reason="closed_with_retry")
                                self.rebalancer.remove_position(spread_id)
                                
                            else:
                                logger.error(f"âŒ Retry failed: {retry_result.comment}")
                                logger.error("Manual intervention required!")
                                # Keep the failed position in monitoring
                        except Exception as e:
                            logger.error(f"âŒ Retry error: {e}")
                            logger.error("Manual intervention required!")
                    else:
                        # Both failed - keep trying
                        logger.warning("Both legs failed to close - will retry on next exit signal")
                    
                    # Check if all positions closed
                    if len(self.position_tracker.positions) == 0:
                        self.flag_manager.mark_setup_inactive("All positions closed (with failures)")
                        logger.info("âœ… Setup flag: INACTIVE (all positions eventually closed)")
                    
                    continue  # Skip to next spread
                
                # BOTH CLOSED SUCCESSFULLY
                logger.info(f"[MT5 SUCCESS] Positions closed:")
                logger.info(f"  Primary: {primary_ticket}")
                logger.info(f"  Secondary: {secondary_ticket}")
                
                # Update tracker
                result = self.position_tracker.close_spread_position(
                    spread_id,
                    gold_result.price,
                    silver_result.price
                )
                
                logger.info(f"[SUCCESS] P&L: ${result['total_pnl']:.2f}")
                
                # Update account
                self.account_balance += result['total_pnl']
                self.position_sizer.update_balance(self.account_balance)
                self.drawdown_monitor.update(self.account_balance)
                self.risk_checker.update_daily_pnl(result['total_pnl'])
                
                # UNREGISTER FROM POSITION MONITOR
                self.position_monitor.unregister_position(primary_ticket)
                self.position_monitor.unregister_position(secondary_ticket)
                
                # Remove from mapping
                del self.mt5_tickets[gold_pos.position_id]
                del self.mt5_tickets[silver_pos.position_id]
                
                # ARCHIVE AND DELETE FROM DISK
                self.persistence.archive_spread(spread_id, reason="closed_normally")
                logger.info(f"[PERSISTENCE] Spread {spread_id[:8]} archived and removed from disk")
                
                # Remove from rebalancer
                self.rebalancer.remove_position(spread_id)
                
                # CHECK IF ALL POSITIONS CLOSED â†’ CLEAR FLAG
                if len(self.position_tracker.positions) == 0:
                    self.flag_manager.mark_setup_inactive("All positions closed")
                    logger.info("âœ… Setup flag: INACTIVE (all positions closed)")
            
        except Exception as e:
            logger.error(f"Exit error: {e}")
            import traceback
            traceback.print_exc()
    
    def _monitor_thread(self):
        """Monitoring thread - syncs positions with MT5 real P&L"""
        logger.info("Monitor thread started")
        
        while self.running:
            try:
                time.sleep(10)
                
                with self.lock:
                    # ========== SYNC POSITIONS WITH MT5 REAL P&L ==========
                    try:
                        import MetaTrader5 as mt5
                        mt5_positions = mt5.positions_get()
                        
                        if mt5_positions:
                            # Update each position with REAL MT5 P&L
                            for mt5_pos in mt5_positions:
                                ticket = mt5_pos.ticket
                                
                                # Find our internal position
                                if ticket in self.mt5_tickets:
                                    spread_id, leg = self.mt5_tickets[ticket]
                                    
                                    # Get our position
                                    positions = self.position_tracker.get_all_positions()
                                    for pos in positions:
                                        if pos.position_id == spread_id + f"_{leg}":
                                            # Update with REAL MT5 P&L (includes spread, commission, swap!)
                                            old_pnl = pos.unrealized_pnl
                                            pos.unrealized_pnl = mt5_pos.profit  # REAL P&L from MT5!
                                            
                                            # Update price too
                                            pos.current_price = mt5_pos.price_current
                                            
                                            # Log if significant difference
                                            pnl_diff = abs(pos.unrealized_pnl - old_pnl)
                                            if pnl_diff > 10:  # $10 difference
                                                logger.debug(f"Position {leg} P&L updated: "
                                                           f"Internal=${old_pnl:.2f}, "
                                                           f"MT5=${mt5_pos.profit:.2f}, "
                                                           f"Diff=${pnl_diff:.2f}")
                                            break
                            
                            # Log total real P&L
                            total_mt5_pnl = sum(p.profit for p in mt5_positions)
                            logger.debug(f"Total MT5 Unrealized P&L: ${total_mt5_pnl:,.2f}")
                        
                    except Exception as e:
                        logger.error(f"MT5 position sync error: {e}")
                    # ========== END MT5 POSITION SYNC ==========
                    
                    if self.last_update_time:
                        try:
                            data = self.data_queue.get_nowait()
                            
                            for position in self.position_tracker.get_all_positions():
                                if position.symbol == 'XAUUSD':
                                    self.position_tracker.update_position_price(
                                        position.position_id,
                                        data['current_primary_price']
                                    )
                                elif position.symbol == 'XAGUSD':
                                    self.position_tracker.update_position_price(
                                        position.position_id,
                                        data['current_secondary_price']
                                    )
                        except queue.Empty:
                            pass
                    
                    pnl_data = self.position_tracker.get_total_pnl()
                    dd_metrics = self.drawdown_monitor.get_metrics()
                    
                    logger.info(f"[STATUS] Balance: ${self.account_balance:,.2f} | "
                               f"Positions: {pnl_data['open_positions']} | "
                               f"P&L: ${pnl_data['unrealized_pnl']:,.2f} | "
                               f"DD: {dd_metrics.current_drawdown_pct:.2%}")
                
            except Exception as e:
                logger.error(f"Monitor error: {e}")
                time.sleep(5)
    
    def _attribution_thread(self):
        """
        Real-time P&L Attribution Thread
        
        Updates every 60 seconds to calculate 7-component attribution
        Features:
        - Kill-switch if directional > 80%
        - Rebalance alert if hedge quality < 0.7
        - Real MT5 swap costs
        """
        logger.info("Attribution thread started (immediate first run, then 60s interval)")
        
        from analytics.pnl_attribution import get_attribution_engine, PositionSnapshot
        from datetime import datetime
        import MetaTrader5 as mt5
        
        attribution_engine = get_attribution_engine()
        
        first_run = True
        
        while self.running:
            try:
                # Sleep AFTER calculation (except first run)
                if not first_run:
                    time.sleep(60)  # Update every 60 seconds
                else:
                    # First run - wait 5 seconds for data thread to initialize
                    time.sleep(5)
                    first_run = False
                
                # Get current market snapshot
                snapshot = self.current_snapshot
                if not snapshot:
                    continue
                
                # Get all MT5 positions
                mt5_positions = mt5.positions_get()
                if not mt5_positions:
                    continue
                
                # Group by spread_id using persistence data
                # Load active positions from disk to get spread_id mapping
                persisted_positions = self.persistence.load_active_positions()
                
                # Build ticket â†’ spread_id mapping
                ticket_to_spread = {}
                for pos_id, pers_pos in persisted_positions.items():
                    ticket_to_spread[pers_pos.mt5_ticket] = pers_pos.spread_id
                
                # Group MT5 positions by spread_id
                spreads = {}
                for pos in mt5_positions:
                    ticket = pos.ticket
                    
                    # Get spread_id from persistence
                    spread_id = ticket_to_spread.get(ticket)
                    
                    if not spread_id:
                        # Position not in persistence (shouldn't happen for our system)
                        logger.debug(f"Position {ticket} not found in persistence, skipping attribution")
                        continue
                    
                    # Determine leg by symbol
                    if "XAU" in pos.symbol or "BTC" in pos.symbol:
                        leg = "PRIMARY"
                    elif "XAG" in pos.symbol or "ETH" in pos.symbol:
                        leg = "SECONDARY"
                    else:
                        leg = "UNKNOWN"
                    
                    if spread_id not in spreads:
                        spreads[spread_id] = {}
                    
                    spreads[spread_id][leg] = pos
                
                # Calculate attribution for each spread
                for spread_id, legs in spreads.items():
                    # Identify primary and secondary positions
                    primary_pos = legs.get("PRIMARY")
                    secondary_pos = legs.get("SECONDARY")
                    
                    if not primary_pos or not secondary_pos:
                        logger.warning(f"Incomplete spread {spread_id}: missing PRIMARY or SECONDARY leg")
                        logger.debug(f"  Available legs: {list(legs.keys())}")
                        continue
                    
                    # Total P&L from MT5 (includes REAL swap!)
                    total_pnl_mt5 = primary_pos.profit + secondary_pos.profit
                    
                    # Current snapshot for attribution
                    current_snapshot = PositionSnapshot(
                        timestamp=datetime.now(),
                        xau_bid=snapshot.primary_bid,
                        xau_ask=snapshot.primary_ask,
                        xag_bid=snapshot.secondary_bid,
                        xag_ask=snapshot.secondary_ask,
                        spread=snapshot.spread,
                        mean=snapshot.spread_mean,
                        std=snapshot.spread_std,
                        zscore=snapshot.zscore,
                        hedge_ratio=snapshot.hedge_ratio,
                        xau_volume=primary_pos.volume,
                        xag_volume=secondary_pos.volume,
                        xau_side='LONG' if primary_pos.type == mt5.ORDER_TYPE_BUY else 'SHORT',
                        xag_side='LONG' if secondary_pos.type == mt5.ORDER_TYPE_BUY else 'SHORT',
                        xau_price=primary_pos.price_current,
                        xag_price=secondary_pos.price_current
                    )
                    
                    # Calculate attribution
                    components = attribution_engine.calculate_attribution(
                        spread_id,
                        current_snapshot,
                        total_pnl_mt5
                    )
                    
                    # Store for GUI (most recent only)
                    self.current_attribution = components
                    
                    logger.debug(f"Attribution {spread_id}: "
                               f"Spread=${components.spread_pnl:.2f} ({components.spread_pnl_pct:.1f}%), "
                               f"Directional=${components.directional_pnl:.2f} ({components.directional_pnl_pct:.1f}%), "
                               f"HedgeQ={components.hedge_quality:.1%}")
                    
                    # ========== KILL-SWITCH LOGIC ==========
                    # If directional risk > 80% AND zscore diverging
                    if abs(components.directional_pnl_pct) > 80:
                        # Check if zscore is diverging (moving away from mean)
                        if spread_id in attribution_engine.positions:
                            entry_zscore = attribution_engine.positions[spread_id]['entry'].zscore
                            current_zscore = snapshot.zscore
                            
                            # Diverging if absolute zscore increased
                            is_diverging = abs(current_zscore) > abs(entry_zscore)
                            
                            if is_diverging:
                                logger.critical(f"ðŸš¨ KILL-SWITCH TRIGGERED for {spread_id}!")
                                logger.critical(f"   Directional: {components.directional_pnl_pct:.1f}% (> 80%)")
                                logger.critical(f"   Z-score: {entry_zscore:.2f} â†’ {current_zscore:.2f} (diverging)")
                                logger.critical(f"   Hedge Quality: {components.hedge_quality:.1%}")
                                
                                # Close positions
                                try:
                                    mt5.Close(primary_pos.ticket)
                                    mt5.Close(secondary_pos.ticket)
                                    logger.critical(f"âœ… Emergency closed spread {spread_id}")
                                    
                                    # Unregister from attribution
                                    attribution_engine.unregister_position(spread_id)
                                except Exception as e:
                                    logger.error(f"Failed to emergency close {spread_id}: {e}")
                    
                    # ========== REBALANCE ALERT ==========
                    if components.hedge_quality < 0.7:
                        logger.warning(f"âš ï¸ HEDGE QUALITY LOW for {spread_id}!")
                        logger.warning(f"   Quality: {components.hedge_quality:.1%} (< 70%)")
                        logger.warning(f"   Directional: {components.directional_pnl_pct:.1f}%")
                        logger.warning(f"   Consider rebalancing")
                    
                    # ========== CRITICAL ALERT ==========
                    if components.hedge_quality < 0.5:
                        logger.critical(f"ðŸ”´ CRITICAL HEDGE FAILURE for {spread_id}!")
                        logger.critical(f"   Quality: {components.hedge_quality:.1%} (< 50%)")
                        logger.critical(f"   Strategy not working properly!")
                
            except Exception as e:
                logger.error(f"Attribution thread error: {e}")
                import traceback
                traceback.print_exc()
    
    def get_status(self):
        """Get system status including attribution"""
        with self.lock:
            pnl_data = self.position_tracker.get_total_pnl()
            dd_metrics = self.drawdown_monitor.get_metrics()
            
            # Attribution data (if available)
            attr = self.current_attribution
            
            status = {
                'running': self.running,
                'balance': self.account_balance,
                'positions': pnl_data['open_positions'],
                'unrealized_pnl': pnl_data['unrealized_pnl'],
                'total_pnl': pnl_data['total_pnl'],
                'drawdown': dd_metrics.current_drawdown_pct,
                'signal': self.current_signal.signal_type.value if self.current_signal else None,
                
                # Attribution components
                'attr_spread_pnl': attr.spread_pnl if attr else 0.0,
                'attr_spread_pct': attr.spread_pnl_pct if attr else 0.0,
                'attr_mean_pnl': attr.mean_drift_pnl if attr else 0.0,
                'attr_mean_pct': attr.mean_drift_pnl_pct if attr else 0.0,
                'attr_directional_pnl': attr.directional_pnl if attr else 0.0,
                'attr_directional_pct': attr.directional_pnl_pct if attr else 0.0,
                'attr_hedge_pnl': attr.hedge_imbalance_pnl if attr else 0.0,
                'attr_hedge_pct': attr.hedge_imbalance_pnl_pct if attr else 0.0,
                'attr_costs': attr.transaction_costs if attr else 0.0,
                'attr_costs_pct': attr.transaction_costs_pct if attr else 0.0,
                'attr_slippage': attr.slippage if attr else 0.0,
                'attr_slippage_pct': attr.slippage_pct if attr else 0.0,
                'attr_rebalance': attr.rebalance_alpha if attr else 0.0,
                'attr_rebalance_pct': attr.rebalance_alpha_pct if attr else 0.0,
                'attr_hedge_quality': attr.hedge_quality if attr else 0.0,
                'attr_purity': attr.strategy_purity if attr else 0.0,
                'attr_classification': attr.classification if attr else 'NO DATA'
            }
            
            return status


def signal_handler(signum, frame):
    """Handle shutdown signals"""
    global system
    logger.info("Shutdown signal received")
    if system:
        system.stop()
    sys.exit(0)


def main():
    """Main entry point"""
    
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       XAU/XAG PAIR TRADING SYSTEM - Multi-Threaded v1.0         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
    
    setup_logging()
    
    # Create complete config for CLI mode - ALL parameters from config!
    from config.settings import PairConfig
    
    cli_config = PairConfig(
        name="XAU_XAG_CLI",
        primary_symbol="XAUUSD",
        secondary_symbol="XAGUSD",
        
        # Trading parameters
        entry_threshold=2.0,
        exit_threshold=0.5,
        stop_loss_zscore=3.5,
        max_positions=3,
        volume_multiplier=1.0,
        
        # Model parameters
        rolling_window_size=200,
        update_interval=60,
        hedge_drift_threshold=0.05,
        
        # Risk parameters
        max_position_pct=20.0,
        max_risk_pct=2.0,
        max_drawdown_pct=20.0,
        daily_loss_limit=5000.0,
        
        # Rebalancer parameters - NO MORE HARDCODED!
        scale_interval=0.5,
        initial_fraction=0.33,
        min_adjustment_interval=3600,
        
        # Feature flags
        enable_pyramiding=True,
        enable_hedge_adjustment=True,
        enable_regime_filter=False,
        
        # System parameters - NO MORE HARDCODED!
        magic_number=234000,
        zscore_history_size=200,
        position_data_dir="positions"
    )
    
    logger.info("Using CLI config:")
    logger.info(f"  Pair: {cli_config.primary_symbol}/{cli_config.secondary_symbol}")
    logger.info(f"  Entry: {cli_config.entry_threshold}, Max Positions: {cli_config.max_positions}")
    logger.info(f"  Scale Interval: {cli_config.scale_interval}, Initial Fraction: {cli_config.initial_fraction}")
    logger.info(f"  Magic Number: {cli_config.magic_number}")
    
    global system
    system = TradingSystem(
        account_balance=100000,
        config=cli_config  # Pass config instead of individual params!
    )
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # Set symbols for CLI mode
    system.market_data.primary_symbol = cli_config.primary_symbol
    system.market_data.secondary_symbol = cli_config.secondary_symbol
    
    system.start()
    
    logger.info("="*70)
    logger.info("SYSTEM RUNNING - Press Ctrl+C to stop")
    logger.info("="*70)
    
    try:
        while True:
            time.sleep(60)
            
            status = system.get_status()
            
            print("\n" + "="*70)
            print(f"STATUS - {datetime.now().strftime('%H:%M:%S')}")
            print("="*70)
            print(f"Balance: ${status['balance']:,.2f}")
            print(f"Positions: {status['positions']}")
            print(f"P&L: ${status['total_pnl']:,.2f}")
            print(f"Drawdown: {status['drawdown']:.2%}")
            print(f"Signal: {status['signal']}")
            print("="*70)
            
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt")
        system.stop()


if __name__ == "__main__":
    main()
